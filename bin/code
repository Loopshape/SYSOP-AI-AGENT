#!/usr/bin/env bash
# ~/bin/code - Interactive AI Code Orchestrator
# Manages multi-model AI reasoning, code generation, internet research, and dynamic data binding.
# This script is intended to be called by 'ai' or external systems.

set -euo pipefail
IFS=$'\n\t'

# -------------------- CONFIG --------------------
AI_HOME="${AI_HOME:-$HOME/.ai_agent}"
PROJECTS_DIR="${PROJECTS_DIR:-$HOME/ai_projects}"
MEMORY_DB="$AI_HOME/memory.db"
CONFIG_DB="$AI_HOME/config.db"
EVENTS_DB="$AI_HOME/events.db"

OLLAMA_BIN="$(command -v ollama || true)"

# CODE specific model defaults - can be overridden by environment variables passed from 'ai'
DEFAULT_MESSENGER_MODEL="gemma3:1b"
DEFAULT_COMBINATOR_MODEL="deepseek-r1:1.5b"
DEFAULT_TRADER_MODEL="2244-1"
DEFAULT_CODE_GEN_MODEL="codellama:7b" # A model specialized for code generation

# Inherit / set AI parameters
CODE_MESSENGER_MODEL="${AI_MODEL:-$DEFAULT_MESSENGER_MODEL}"
CODE_COMBINATOR_MODEL="${AI_MODEL:-$DEFAULT_COMBINATOR_MODEL}"
CODE_TRADER_MODEL="${AI_MODEL:-$DEFAULT_TRADER_MODEL}"
CODE_CODE_GEN_MODEL="${AI_CODE_MODEL:-$DEFAULT_CODE_GEN_MODEL}" # Specific model for code generation
CODE_TEMPERATURE="${AI_TEMPERATURE:-0.7}"
CODE_TOP_P="${AI_TOP_P:-0.9}"
CODE_SEED="${AI_SEED:-}"

# Termux detection - FIX: Use parameter expansion to prevent unbound variable error
IS_TERMUX=false
[[ -n "${PREFIX:-}" && -d "${PREFIX:-}" && "$(uname -o 2>/dev/null)" == "Android" ]] && IS_TERMUX=true

# Colors
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'; PURPLE='\033[0;35m'; CYAN='\033[0;36m'; NC='\033[0m'

# -------------------- LOGGING --------------------
log() { printf "${BLUE}[%s][CODE]${NC} %s\n" "$(date '+%T')" "$*"; } # Updated to [CODE] tag
log_success() { log "${GREEN}$*${NC}"; }
log_warn() { log "${YELLOW}WARN: $*${NC}"; }
log_error() { log "${RED}ERROR: $*${NC}"; exit 1; }
log_info() { log "${CYAN}$*${NC}"; }
log_phase() { echo -e "\n${PURPLE}▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓${NC}"; log "${PURPLE}$*${NC}"; echo -e "${PURPLE}▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓${NC}"; }

# -------------------- DATABASE FUNCTIONS --------------------
sqlite_escape() { echo "$1" | sed "s/'/''/g"; }
add_to_memory() { sqlite3 "$MEMORY_DB" "INSERT INTO memories (prompt,response,task_id) VALUES ('$(sqlite_escape "$1")','$(sqlite_escape "$2")','$3');" 2>/dev/null; }
search_memory() { sqlite3 -header -column "$MEMORY_DB" "SELECT timestamp,prompt,response FROM memories WHERE prompt LIKE '%$(sqlite_escape "$1")%' ORDER BY timestamp DESC LIMIT 5;" 2>/dev/null; }
add_event_to_db() {
    local event_data="$1"
    local current_timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local event_hash=$(echo -n "$event_data" | sha256sum | cut -c1-64)
    if sqlite3 "$EVENTS_DB" "INSERT INTO events (timestamp, event_hash, event_data) VALUES ('$(sqlite_escape "$current_timestamp")', '$(sqlite_escape "$event_hash")', '$(sqlite_escape "$event_data")');" 2>/dev/null; then
        log_success "Event added to CODE index with hash: $event_hash"
        echo "$event_hash"
    else
        if sqlite3 "$EVENTS_DB" "SELECT 1 FROM events WHERE event_hash = '$(sqlite_escape "$event_hash")';" 2>/dev/null; then
            log_info "Event with hash $event_hash already exists in CODE index."
            echo "$event_hash"
        else
            log_error "Failed to add event to CODE index for hash: $event_hash"
            return 1
        fi
    fi
}

gen_task_id() { echo -n "${1:-}$(date +%s%N)$RANDOM${CODE_SEED:-}" | sha256sum | cut -c1-16; }

confirm_action() { echo -e "${YELLOW}CONFIRM: $1${NC}"; read -p "Type 'yes' to confirm: " -r r; [[ "$r" == "yes" ]]; }

# -------------------- AI WORKER FUNCTIONS (internal to CODE) --------------------
ensure_ollama_server() { pgrep -f "ollama serve" >/dev/null || (log "Ollama server starting..."; nohup "$OLLAMA_BIN" serve >/dev/null 2>&1 & sleep 3); }

# This version of run_worker_raw captures verbose output for "spotted tokens"
run_worker_raw_with_verbose_capture() {
    local model="$1" system_prompt="$2" conversation_history="$3"
    local output_format="${4:-text}" # 'text' or 'json'
    ensure_ollama_server
    local response_buffer=""
    local verbose_output_buffer=""
    local fifo=$(mktemp -u)
    mkfifo "$fifo"

    ( "$OLLAMA_BIN" run --verbose "$model" --temperature "$CODE_TEMPERATURE" --top_p "$CODE_TOP_P" ${CODE_SEED:+--seed "$CODE_SEED"} "$system_prompt"$'\n'"$conversation_history" 2>&1 > "$fifo" ) &
    local pid=$!

    while IFS= read -r line <"$fifo"; do
        [[ -z "$line" ]] && continue
        if [[ "$line" =~ ^\>\>\> ]]; then
            echo -e "${YELLOW}$line${NC}" >&2 # Log verbose to stderr for interactive view
            verbose_output_buffer+="$line"$'\n'
        elif [[ "$line" =~ ^\{.*\}$ ]]; then
            token=$(echo "$line" | jq -r '.response? // empty' 2>/dev/null)
            done_status=$(echo "$line" | jq -r '.done? // false' 2>/dev/null)
            [[ -n "$token" ]] && { printf '%s' "$token"; response_buffer+="$token"; }
            [[ "$done_status" == "true" ]] && printf '\n'
        else
            echo -e "${BLUE}$line${NC}" >&2 # Log other ollama output to stderr
            verbose_output_buffer+="$line"$'\n'
        fi
    done
    wait "$pid" 2>/dev/null || true
    rm -f "$fifo"
    
    if [[ "$output_format" == "json" ]]; then
        local escaped_response=$(jq -n --arg res "$response_buffer" '$res')
        local escaped_verbose=$(jq -n --arg verb "$verbose_output_buffer" '$verb')
        echo "{\"ai_response\": $escaped_response, \"verbose_output\": $escaped_verbose}"
    else
        echo -e "---AI_RESPONSE_START---\n$response_buffer\n---AI_RESPONSE_END---"
        echo -e "---VERBOSE_OUTPUT_START---\n$verbose_output_buffer\n---VERBOSE_OUTPUT_END---"
    fi
}

# -------------------- CODE-SPECIFIC TOOLS (internal, AI can decide to use) --------------------
tool_web_search_internal() {
    local query="$1"
    log_info "CODE initiating internal web search for: $query"
    # No user confirmation needed for internal AI-driven search
    local search_results=$(curl -sL "https://html.duckduckgo.com/html/?q=$(jq -nr --arg q "$query" '$q|@uri')" | lynx -dump -stdin -nolist)
    if [[ -z "$search_results" ]]; then
        log_warn "Internal web search for '$query' returned no results or failed."
        echo "NO_RESULTS"
    else
        log_success "Internal web search for '$query' completed."
        echo "$search_results"
    fi
}

tool_write_file_internal() {
    local file_path="$1"
    local file_content="$2"
    log_info "CODE attempting to write file: $file_path"
    mkdir -p "$(dirname "$file_path")" || { log_error "Failed to create directory for $file_path"; return 1; }
    echo -e "$file_content" > "$file_path" || { log_error "Failed to write content to $file_path"; return 1; }
    log_success "File written successfully: $file_path"
    return 0
}

# -------------------- CODE ORCHESTRATION MAIN LOOP --------------------
run_code_orchestration() {
    local initial_user_prompt="$1"
    local output_format="${2:-text}" # 'text' for CLI, 'json' for websocket

    log_phase "CODE ORCHESTRATION: Starting for prompt: $initial_user_prompt"
    local task_id=$(gen_task_id "$initial_user_prompt")
    local task_dir="$PROJECTS_DIR/$task_id"
    mkdir -p "$task_dir"
    log_success "Task ID: $task_id"
    log_info "Workspace: $task_dir"

    local current_context="$initial_user_prompt"
    local total_loops=0
    local MAX_LOOPS=5 # Limit AI thought loops to prevent endless cycles

    local final_ai_response=""
    local generated_solution_path=""

    while [[ "$total_loops" -lt "$MAX_LOOPS" ]]; do
        total_loops=$((total_loops + 1))
        log_phase "CODE Thought Loop #$total_loops"

        local relevant_memories=$(search_memory "$current_context")

        # --- Phase 1: Async Brainstorming ---
        local messenger_prompt="MESSENGER analyzing the problem and current context: $current_context. What actions are implied (e.g., RESEARCH, GENERATE_CODE, FINAL_ANSWER)?"
        local combinator_prompt="COMBINATOR brainstorming next steps, potential solutions, and required research for: $current_context. Suggest specific actions like 'RESEARCH <query>', 'GENERATE_CODE', or a '[FINAL_ANSWER]' if the problem is solved."

        local m_output_raw=$(run_worker_raw_with_verbose_capture "$CODE_MESSENGER_MODEL" "$messenger_prompt" "$relevant_memories" "text")
        local messenger_response=$(echo "$m_output_raw" | sed -n '/---AI_RESPONSE_START---/,/---AI_RESPONSE_END---/{//!p}')
        local messenger_verbose=$(echo "$m_output_raw" | sed -n '/---VERBOSE_OUTPUT_START---/,/---VERBOSE_OUTPUT_END---/{//!p}')
        
        local c_output_raw=$(run_worker_raw_with_verbose_capture "$CODE_COMBINATOR_MODEL" "$combinator_prompt" "$relevant_memories" "text")
        local combinator_response=$(echo "$c_output_raw" | sed -n '/---AI_RESPONSE_START---/,/---AI_RESPONSE_END---/{//!p}')
        local combinator_verbose=$(echo "$c_output_raw" | sed -n '/---VERBOSE_OUTPUT_START---/,/---VERBOSE_OUTPUT_END---/{//!p}')

        # Store verbose thinking for learning/hashing strategy
        add_event_to_db "Messenger Verbose ($task_id, Loop $total_loops):\n$messenger_verbose" >/dev/null
        add_event_to_db "Combinator Verbose ($task_id, Loop $total_loops):\n$combinator_verbose" >/dev/null

        # --- Analysis of Verbose Output for "Spotted Tokens" and Action Decision ---
        log_info "Analyzing verbose output for action triggers and spotted tokens..."
        local all_llm_output="$messenger_response"$'\n'"$combinator_response" # Now check LLM direct responses
        local spotted_actions=$(analyze_verbose_for_tokens "$all_llm_output" "$current_context")
        
        local action_decision=""
        local research_query=""

        # Prioritize explicit actions from LLM responses
        if echo "$spotted_actions" | grep -qi "\[FINAL_ANSWER\]"; then
            action_decision="FINAL_ANSWER"
        elif echo "$spotted_actions" | grep -qi "GENERATE_CODE"; then
            action_decision="GENERATE_CODE"
        elif echo "$spotted_actions" | grep -qi "RESEARCH"; then
            research_query=$(echo "$all_llm_output" | grep -oP '(?i)RESEARCH (.*?)(?=\[|$)' | head -n 1 | sed 's/RESEARCH //i')
            if [[ -n "$research_query" ]]; then
                action_decision="RESEARCH"
            fi
        fi

        log_info "CODE Decision: $action_decision"

        case "$action_decision" in
            "RESEARCH")
                if [[ -n "$research_query" ]]; then
                    log_info "Performing research for: '$research_query'"
                    local research_results=$(tool_web_search_internal "$research_query")
                    add_event_to_db "Research Results for '$research_query':\n$research_results" >/dev/null
                    current_context+=" (Research results for '$research_query': $research_results)"
                else
                    log_warn "AI indicated research but no specific query was extracted. Proceeding without new research."
                fi
                ;;
            "GENERATE_CODE")
                log_info "AI decided to generate code. Preparing prompt..."
                local code_gen_instruction="Based on the following user prompt and context, generate the requested code. Focus on the core functionality. Output ONLY the code, no conversational text or markdown wrappers like \`\`\` (unless specifically for a file format like markdown itself).
                User Prompt: $initial_user_prompt
                Current Context: $current_context
                If the request implies an HTML file, provide a complete HTML5 document including relevant JS/CSS links.
                For shell scripts, provide a complete, executable bash script.
                For JS, provide just the JavaScript.
                Ensure correct MIME types, three.js, gsap, jquery3 are integrated if specified.
                Consider dynamics for energy and entropy for simulations, if applicable.
                "
                local code_output_raw=$(run_worker_raw_with_verbose_capture "$CODE_CODE_GEN_MODEL" "$code_gen_instruction" "$relevant_memories" "text")
                local generated_code=$(echo "$code_output_raw" | sed -n '/---AI_RESPONSE_START---/,/---AI_RESPONSE_END---/{//!p}')
                local code_gen_verbose=$(echo "$code_output_raw" | sed -n '/---VERBOSE_OUTPUT_START---/,/---VERBOSE_OUTPUT_END---/{//!p}')
                add_event_to_db "Code Generation Verbose ($task_id, Loop $total_loops):\n$code_gen_verbose" >/dev/null

                if [[ -n "$generated_code" ]]; then
                    log_success "Code generated. Suggesting file save."
                    
                    local default_filename="solution_$(date +%s%N).html" # Default to html
                    if echo "$initial_user_prompt" | grep -qi "shellscript"; then default_filename="solution_$(date +%s%N).sh"; fi
                    if echo "$initial_user_prompt" | grep -qi "javascript"; then default_filename="solution_$(date +%s%N).js"; fi
                    if echo "$initial_user_prompt" | grep -qi "css"; then default_filename="solution_$(date +%s%N).css"; fi

                    local suggested_path="$task_dir/$default_filename"
                    echo -e "${GREEN}CODE generated a solution. Proposed file path: ${YELLOW}$suggested_path${NC}"
                    echo -e "${YELLOW}Review the code below. Type 'yes' to save to this path, or provide a new path. Type 'no' to discard.${NC}"
                    echo -e "\n---\n${generated_code}\n---"

                    read -p "Save? (yes/no/[new path]): " -r save_choice
                    save_choice="${save_choice,,}" # Convert to lowercase

                    if [[ "$save_choice" == "yes" ]]; then
                        if tool_write_file_internal "$suggested_path" "$generated_code"; then
                            log_success "Solution saved to $suggested_path"
                            generated_solution_path="$suggested_path"
                            final_ai_response="[FINAL_ANSWER] Solution generated and saved to: $generated_solution_path"
                        else
                            log_error "Failed to save solution to $suggested_path."
                            final_ai_response="Failed to generate and save solution."
                        fi
                    elif [[ "$save_choice" == "no" ]]; then
                        log_info "Solution discarded by user."
                        final_ai_response="Solution generated but discarded by user. Proceeding with further analysis if needed."
                    else # User provided a new path
                        if tool_write_file_internal "$save_choice" "$generated_code"; then
                            log_success "Solution saved to $save_choice"
                            generated_solution_path="$save_choice"
                            final_ai_response="[FINAL_ANSWER] Solution generated and saved to: $generated_solution_path"
                        else
                            log_error "Failed to save solution to $save_choice."
                            final_ai_response="Failed to generate and save solution."
                        fi
                    fi
                    add_to_memory "$initial_user_prompt" "$final_ai_response" "$task_id"
                    echo "$final_ai_response"
                    return 0 # Exit after generating and handling code
                else
                    log_warn "AI attempted code generation but produced no output. Will try to re-evaluate."
                    current_context+=" (Previous attempt to generate code yielded no output.)"
                fi
                ;;
            "FINAL_ANSWER")
                log_success "AI produced a final answer."
                # The final_ai_response should already contain the FINAL_ANSWER tag from LLM
                final_ai_response="$all_llm_output" # Capture final answer from LLM output
                add_to_memory "$initial_user_prompt" "$final_ai_response" "$task_id"
                echo "$final_ai_response"
                return 0 # Exit loop, problem solved
                ;;
            *)
                # Default behavior: synthesize and continue the loop if not solved
                log_info "No explicit action decided, synthesizing current thoughts for next loop."
                local trader_prompt="TRADER merging Messenger & Combinator. Based on the problem: '$initial_user_prompt' and current context: '$current_context'. Provide an updated comprehensive thought process. If the solution is ready for code, suggest 'GENERATE_CODE'. If the final solution or answer is ready, provide a '[FINAL_ANSWER] <your answer>'.
---MESSENGER ANALYSIS---
$messenger_response
---COMBINATOR BRAINSTORM---
$combinator_response"
                local t_output_raw=$(run_worker_raw_with_verbose_capture "$CODE_TRADER_MODEL" "$trader_prompt" "$relevant_memories" "text")
                local trader_response=$(echo "$t_output_raw" | sed -n '/---AI_RESPONSE_START---/,/---AI_RESPONSE_END---/{//!p}')
                local trader_verbose=$(echo "$t_output_raw" | sed -n '/---VERBOSE_OUTPUT_START---/,/---VERBOSE_OUTPUT_END---/{//!p}')
                add_event_to_db "Trader Verbose ($task_id, Loop $total_loops):\n$trader_verbose" >/dev/null

                log_info "Trader's current synthesis:\n$trader_response"
                current_context+=" (Trader's thoughts: $trader_response)"
                # Check for final answer or GENERATE_CODE in trader's response too
                if echo "$trader_response" | grep -qi "\[FINAL_ANSWER\]"; then
                    final_ai_response="$trader_response"
                    add_to_memory "$initial_user_prompt" "$final_ai_response" "$task_id"
                    echo "$final_ai_response"
                    return 0 # Exit loop, problem solved
                elif echo "$trader_response" | grep -qi "GENERATE_CODE"; then
                    action_decision="GENERATE_CODE" # Force next loop to generate code
                    current_context+=" (Trader explicitly suggested GENERATE_CODE for the next step.)"
                fi
                ;;
        esac
    done

    # If loop finishes without a FINAL_ANSWER
    if [[ -z "$final_ai_response" ]]; then
        log_warn "CODE orchestration loop finished without a definitive [FINAL_ANSWER]. Providing last known context."
        final_ai_response="CODE could not definitively solve the prompt: '$initial_user_prompt' within $MAX_LOOPS loops. Last context: $current_context"
        add_to_memory "$initial_user_prompt" "$final_ai_response" "$task_id"
        echo "$final_ai_response"
    fi
    return 0
}

# Function to spot action triggers (RESEARCH, GENERATE_CODE, FINAL_ANSWER) and entities
analyze_verbose_for_tokens() {
    local text_to_analyze="$1"
    local original_prompt="$2"
    
    local spotted_actions=""
    
    # Explicit action phrases
    if echo "$text_to_analyze" | grep -qi "\[FINAL_ANSWER\]"; then
        spotted_actions+="[FINAL_ANSWER] "
    fi
    if echo "$text_to_analyze" | grep -qi "GENERATE_CODE"; then
        spotted_actions+="GENERATE_CODE "
    fi
    if echo "$text_to_analyze" | grep -qi "RESEARCH"; then
        spotted_actions+="RESEARCH "
    fi

    # Implied code generation if prompt contains "build", "create", "html", "js", etc.
    # And if no explicit action already set, or if it's currently RESEARCH.
    # This acts as a stronger hint to move to code generation.
    if [[ -z "$spotted_actions" || "$spotted_actions" =~ "RESEARCH" ]] ; then
        if echo "$original_prompt" | grep -qiE '(build|create|implement|write|show).*(html|javascript|js|three.js|webgl|gsap|jquery3|css3|script|file)'; then
            if ! echo "$spotted_actions" | grep -qi "GENERATE_CODE"; then
                spotted_actions+="GENERATE_CODE "
            fi
        fi
    fi
    
    echo "$spotted_actions" | sed 's/ *$//' # Trim trailing space
}


# -------------------- WEBSOCKETD INTEGRATION (Conceptual) --------------------
# This is largely identical to the previous DEX script, but points to `run_code_orchestration`.
handle_websocket_mode() {
    log_info "CODE is running in WebSocket mode."
    if ! command -v jq >/dev/null; then
        log_error "jq is required for WebSocket JSON processing. Please install it."
    fi

    while IFS= read -r line; do
        local current_timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        log_info "Received WebSocket message at $current_timestamp: $line" >&2 # Log to stderr

        local command=""
        local payload=""
        
        if echo "$line" | jq -e . >/dev/null 2>&1; then
            command=$(echo "$line" | jq -r '.command // empty')
            payload=$(echo "$line" | jq -r '.payload // empty')
        else
            log_warn "Invalid JSON received: $line" >&2
            echo "{\"status\": \"error\", \"message\": \"Invalid JSON input.\"}"
            continue
        fi

        local response_json=""
        case "$command" in
            "prompt")
                response_json=$(run_code_orchestration "$payload" "json")
                if [[ $? -eq 0 ]]; then
                    echo "$response_json"
                else
                    echo "{\"status\": \"error\", \"message\": \"CODE orchestration failed for prompt: $(jq -n --arg p "$payload" '$p')\"}"
                fi
                ;;
            "get_memory")
                local mem_search_results=$(search_memory "$payload")
                local escaped_results=$(jq -n --arg res "$mem_search_results" '$res')
                echo "{\"status\": \"success\", \"command\": \"get_memory\", \"query\": $(jq -n --arg p "$payload" '$p'), \"results\": $escaped_results}"
                ;;
            "submit_event")
                local event_hash=$(add_event_to_db "$payload")
                if [[ $? -eq 0 ]]; then
                    echo "{\"status\": \"success\", \"command\": \"submit_event\", \"event_hash\": \"$event_hash\", \"message\": \"Event indexed.\"}"
                else
                    echo "{\"status\": \"error\", \"command\": \"submit_event\", \"message\": \"Failed to index event data.\"}"
                fi
                ;;
            *)
                echo "{\"status\": \"error\", \"message\": \"Unknown WebSocket command: $(jq -n --arg c "$command" '$c')\"}"
                ;;
        esac
    done
}


# -------------------- MAIN --------------------
main() {
    # Initialize DBs (ensuring they exist)
    mkdir -p "$AI_HOME" "$PROJECTS_DIR"
    sqlite3 "$MEMORY_DB" "CREATE TABLE IF NOT EXISTS memories (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP, prompt TEXT, response TEXT, task_id TEXT);" 2>/dev/null || true
    sqlite3 "$CONFIG_DB" "CREATE TABLE IF NOT EXISTS config (key TEXT PRIMARY KEY, value TEXT);" 2>/dev/null || true
    sqlite3 "$EVENTS_DB" "CREATE TABLE IF NOT EXISTS events (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP, event_hash TEXT UNIQUE, event_data TEXT);" 2>/dev/null || true

    if [[ "${1:-}" == "--websocket-mode" ]]; then
        shift # Remove --websocket-mode
        handle_websocket_mode "$@"
    elif [[ $# -eq 0 ]]; then
        log_error "CODE expects a prompt or '--websocket-mode'. Usage: code \"task description\" or code --websocket-mode"
        exit 1
    else
        run_code_orchestration "$@" "text" # Default to text output for CLI calls
    fi
}

trap 'log_warn "Interrupted CODE orchestrator process"; exit 1' INT TERM
[[ "${BASH_SOURCE[0]}" == "${0}" ]] && main "$@"
