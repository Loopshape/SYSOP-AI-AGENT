#!/usr/bin/env bash
# ~/bin/dex - Interactive AI Orchestrator
# Manages multi-model AI reasoning, verbose thinking, and dynamic data binding.
# This script is intended to be called by 'web' or external systems.

set -euo pipefail
IFS=$'\n\t'

# -------------------- CONFIG --------------------
AI_HOME="${AI_HOME:-$HOME/.ai_agent}"
PROJECTS_DIR="${PROJECTS_DIR:-$HOME/ai_projects}"
MEMORY_DB="$AI_HOME/memory.db" # Dex will also use the same memory DB
CONFIG_DB="$AI_HOME/config.db"
EVENTS_DB="$AI_HOME/events.db" # Dex will also use the same events DB

OLLAMA_BIN="$(command -v ollama || true)"

# DEX specific model defaults - can be overridden by environment variables passed from 'web'
DEFAULT_MESSENGER_MODEL="gemma3:1b"
DEFAULT_COMBINATOR_MODEL="deepseek-r1:1.5b"
DEFAULT_TRADER_MODEL="2244-1"

# Inherit / set AI parameters
DEX_MESSENGER_MODEL="${AI_MODEL:-$DEFAULT_MESSENGER_MODEL}" # AI_MODEL env var takes precedence
DEX_COMBINATOR_MODEL="${AI_MODEL:-$DEFAULT_COMBINATOR_MODEL}"
DEX_TRADER_MODEL="${AI_MODEL:-$DEFAULT_TRADER_MODEL}"
DEX_TEMPERATURE="${AI_TEMPERATURE:-0.7}"
DEX_TOP_P="${AI_TOP_P:-0.9}"
DEX_SEED="${AI_SEED:-}"

# Termux detection - FIX: Use parameter expansion to prevent unbound variable error
IS_TERMUX=false
[[ -n "${PREFIX:-}" && -d "${PREFIX:-}" && "$(uname -o 2>/dev/null)" == "Android" ]] && IS_TERMUX=true

# Colors
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; BLUE='\033[0;34m'; PURPLE='\033[0;35m'; CYAN='\033[0;36m'; NC='\033[0m'

# -------------------- LOGGING --------------------
log() { printf "${BLUE}[%s][DEX]${NC} %s\n" "$(date '+%T')" "$*"; }
log_success() { log "${GREEN}$*${NC}"; }
log_warn() { log "${YELLOW}WARN: $*${NC}"; }
log_error() { log "${RED}ERROR: $*${NC}"; exit 1; }
log_info() { log "${CYAN}$*${NC}"; }
log_phase() { echo -e "\n${PURPLE}▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓${NC}"; log "${PURPLE}$*${NC}"; echo -e "${PURPLE}▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓${NC}"; }

# -------------------- DATABASE FUNCTIONS (shared with web, but local to dex context) --------------------
sqlite_escape() { echo "$1" | sed "s/'/''/g"; }
add_to_memory() { sqlite3 "$MEMORY_DB" "INSERT INTO memories (prompt,response,task_id) VALUES ('$(sqlite_escape "$1")','$(sqlite_escape "$2")','$3');" 2>/dev/null; }
search_memory() { sqlite3 -header -column "$MEMORY_DB" "SELECT timestamp,prompt,response FROM memories WHERE prompt LIKE '%$(sqlite_escape "$1")%' ORDER BY timestamp DESC LIMIT 5;" 2>/dev/null; }
# For events, dex might do more complex indexing/processing than web's simple local store
add_event_to_db() {
    local event_data="$1"
    local current_timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local event_hash=$(echo -n "$event_data" | sha256sum | cut -c1-64)
    if sqlite3 "$EVENTS_DB" "INSERT INTO events (timestamp, event_hash, event_data) VALUES ('$(sqlite_escape "$current_timestamp")', '$(sqlite_escape "$event_hash")', '$(sqlite_escape "$event_data")');" 2>/dev/null; then
        log_success "Event added to DEX index with hash: $event_hash"
        echo "$event_hash"
    else
        if sqlite3 "$EVENTS_DB" "SELECT 1 FROM events WHERE event_hash = '$(sqlite_escape "$event_hash")';" 2>/dev/null; then
            log_info "Event with hash $event_hash already exists in DEX index."
            echo "$event_hash"
        else
            log_error "Failed to add event to DEX index for hash: $event_hash"
            return 1
        fi
    fi
}


gen_task_id() { echo -n "$1$(date +%s%N)$RANDOM${DEX_SEED:-}" | sha256sum | cut -c1-16; }

# -------------------- AI WORKER --------------------
ensure_ollama_server() { pgrep -f "ollama serve" >/dev/null || (log "Ollama server starting..."; nohup "$OLLAMA_BIN" serve >/dev/null 2>&1 & sleep 3); }

# This version of run_worker_raw captures verbose output for "spotted tokens"
run_worker_raw_with_verbose_capture() {
    local model="$1" system_prompt="$2" conversation_history="$3"
    ensure_ollama_server
    local response_buffer=""
    local verbose_output_buffer=""
    local fifo=$(mktemp -u)
    mkfifo "$fifo"

    ( "$OLLAMA_BIN" run --verbose "$model" --temperature "$DEX_TEMPERATURE" --top_p "$DEX_TOP_P" ${DEX_SEED:+--seed "$DEX_SEED"} "$system_prompt"$'\n'"$conversation_history" 2>&1 > "$fifo" ) &
    local pid=$!

    while IFS= read -r line <"$fifo"; do
        [[ -z "$line" ]] && continue
        if [[ "$line" =~ ^\>\>\> ]]; then
            echo -e "${YELLOW}$line${NC}" >&2 # Log verbose to stderr for interactive view
            verbose_output_buffer+="$line"$'\n'
        elif [[ "$line" =~ ^\{.*\}$ ]]; then
            token=$(echo "$line" | jq -r '.response? // empty' 2>/dev/null)
            done_status=$(echo "$line" | jq -r '.done? // false' 2>/dev/null)
            [[ -n "$token" ]] && { printf '%s' "$token"; response_buffer+="$token"; }
            [[ "$done_status" == "true" ]] && printf '\n'
        else
            echo -e "${BLUE}$line${NC}" >&2 # Log other ollama output to stderr
            verbose_output_buffer+="$line"$'\n'
        fi
    done
    wait "$pid" 2>/dev/null || true
    rm -f "$fifo"
    
    # Return both the AI response and the verbose output (separated, or in a structured format)
    echo -e "---AI_RESPONSE_START---\n$response_buffer\n---AI_RESPONSE_END---"
    echo -e "---VERBOSE_OUTPUT_START---\n$verbose_output_buffer\n---VERBOSE_OUTPUT_END---"
}


# -------------------- DEX ORCHESTRATION --------------------
# This is the core of DEX, replacing run_triumvirate_agent
run_dex_orchestration() {
    local initial_user_prompt="$*"
    log_phase "DEX ORCHESTRATION: Initiating for prompt: $initial_user_prompt"
    local task_id=$(gen_task_id "$initial_user_prompt")
    local task_dir="$PROJECTS_DIR/$task_id"
    mkdir -p "$task_dir"
    log_success "Task ID: $task_id"
    log_info "Workspace: $task_dir"

    local relevant_memories=$(search_memory "$initial_user_prompt")

    # --- Phase 1: Async Brainstorming with Verbose Capture ---
    log_phase "DEX Phase 1: Async Brainstorming"
    local messenger_prompt="MESSENGER analyzing: $initial_user_prompt"
    local combinator_prompt="COMBINATOR brainstorming: $initial_user_prompt"

    local m_output_raw=$(run_worker_raw_with_verbose_capture "$DEX_MESSENGER_MODEL" "$messenger_prompt" "$relevant_memories")
    local messenger_response=$(echo "$m_output_raw" | sed -n '/---AI_RESPONSE_START---/,/---AI_RESPONSE_END---/{//!p}')
    local messenger_verbose=$(echo "$m_output_raw" | sed -n '/---VERBOSE_OUTPUT_START---/,/---VERBOSE_OUTPUT_END---/{//!p}')
    
    local c_output_raw=$(run_worker_raw_with_verbose_capture "$DEX_COMBINATOR_MODEL" "$combinator_prompt" "$relevant_memories")
    local combinator_response=$(echo "$c_output_raw" | sed -n '/---AI_RESPONSE_START---/,/---AI_RESPONSE_END---/{//!p}')
    local combinator_verbose=$(echo "$c_output_raw" | sed -n '/---VERBOSE_OUTPUT_START---/,/---VERBOSE_OUTPUT_END---/{//!p}')

    # --- Analysis of Verbose Output for "Spotted Tokens" ---
    log_info "Analyzing verbose output for spotted tokens..."
    local all_verbose_output="$messenger_verbose"$'\n'"$combinator_verbose"
    local spotted_tokens=$(analyze_verbose_for_tokens "$all_verbose_output" "$initial_user_prompt")
    if [[ -n "$spotted_tokens" ]]; then
        log_info "Spotted Tokens: $spotted_tokens"
        # Here's where DEX could dynamically decide to perform file access or URL fetches
        # For this example, we'll just add them to the prompt.
        initial_user_prompt+=" (Also consider these spotted tokens in further analysis: $spotted_tokens)"
    fi

    # --- Phase 2: Synthesis & Execution ---
    log_phase "DEX Phase 2: Synthesis & Execution"
    local trader_prompt="TRADER merging Messenger & Combinator.
---MESSENGER ANALYSIS---
$messenger_response
---COMBINATOR BRAINSTORM---
$combinator_response
---USER PROMPT & FINAL ANSWER---
$initial_user_prompt" # Potentially augmented with spotted tokens

    local t_output_raw=$(run_worker_raw_with_verbose_capture "$DEX_TRADER_MODEL" "$trader_prompt" "$relevant_memories")
    local trader_response=$(echo "$t_output_raw" | sed -n '/---AI_RESPONSE_START---/,/---AI_RESPONSE_END---/{//!p}')
    local trader_verbose=$(echo "$t_output_raw" | sed -n '/---VERBOSE_OUTPUT_START---/,/---VERBOSE_OUTPUT_END---/{//!p}')

    log_phase "DEX Phase 3: Finalization"
    log_success "DEX AI response generated. Adding to memory."
    add_to_memory "$initial_user_prompt" "$trader_response" "$task_id"

    # Print the final trader response to stdout (which 'web' will capture)
    echo "$trader_response"
    
    # Optionally, dump all verbose output to a log file in the task directory
    echo "$messenger_verbose" > "$task_dir/messenger_verbose.log"
    echo "$combinator_verbose" > "$task_dir/combinator_verbose.log"
    echo "$trader_verbose" > "$task_dir/trader_verbose.log"
    log_info "Detailed verbose logs saved in $task_dir."
}

# Placeholder function for spotting tokens. This would be a specialized AI task.
analyze_verbose_for_tokens() {
    local verbose_text="$1"
    local original_prompt="$2"
    # In a real scenario, you'd send `verbose_text` to an LLM
    # with a prompt like "Extract key entities, concepts, or potential data sources from this AI's verbose thinking."
    # For now, a simple grep/awk based on keywords or patterns.
    echo "$verbose_text" | grep -oE '\b(url|file|html|dom|javascript|ollama|agent|memory|config)\b' | sort -u | tr '\n' ' ' | sed 's/ *$//'
}

# -------------------- WEBSOCKETD INTEGRATION (Conceptual) --------------------
# How 'websocketd' would connect to this 'dex' script:
# websocketd --port=8080 -- /path/to/dex.sh --websocket-mode

# In --websocket-mode, dex would read JSON messages from stdin,
# process them, and write JSON responses to stdout.
# Each line from stdin/stdout would be a JSON object.

# Example for websocketd mode (requires more robust JSON parsing in bash, or a Python/Node.js wrapper)
# handle_websocket_mode() {
#    while IFS= read -r line; do
#        # Parse incoming JSON message from client
#        local client_message=$(echo "$line" | jq -r '.')
#        local command=$(echo "$client_message" | jq -r '.command // empty')
#        local payload=$(echo "$client_message" | jq -r '.payload // empty')
#        local client_id=$(echo "$client_message" | jq -r '.client_id // "anonymous"')
#
#        log_info "Received WebSocket command: $command from $client_id with payload: $payload"
#
#        local response_payload=""
#        case "$command" in
#            "prompt")
#                # Run orchestration and capture response
#                response_payload=$(run_dex_orchestration "$payload")
#                echo "{\"status\": \"success\", \"response\": \"$response_payload\"}"
#                ;;
#            "get_memory")
#                response_payload=$(search_memory "$payload")
#                echo "{\"status\": \"success\", \"memory\": \"$(echo "$response_payload" | jq -Rs .)\"}"
#                ;;
#            # ... other commands ...
#            *)
#                echo "{\"status\": \"error\", \"message\": \"Unknown command: $command\"}"
#                ;;
#        esac
#    done
# }


# -------------------- MAIN --------------------
main() {
    # Initialize DBs (ensuring they exist)
    mkdir -p "$AI_HOME" "$PROJECTS_DIR"
    sqlite3 "$MEMORY_DB" "CREATE TABLE IF NOT EXISTS memories (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP, prompt TEXT, response TEXT, task_id TEXT);" 2>/dev/null || true
    sqlite3 "$CONFIG_DB" "CREATE TABLE IF NOT EXISTS config (key TEXT PRIMARY KEY, value TEXT);" 2>/dev/null || true
    sqlite3 "$EVENTS_DB" "CREATE TABLE IF NOT EXISTS events (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP, event_hash TEXT UNIQUE, event_data TEXT);" 2>/dev/null || true


    if [[ "$1" == "--websocket-mode" ]]; then
        log_info "Starting in WebSocket mode. Listening on stdin/stdout for JSON messages."
        # handle_websocket_mode # Uncomment and implement this function for actual websocketd use
        log_error "WebSocket mode is conceptual and not fully implemented for JSON parsing in pure bash. Consider a Python/Node.js wrapper for DEX."
        exit 1
    elif [[ $# -eq 0 ]]; then
        log_error "DEX expects a prompt or '--websocket-mode'. Usage: dex \"task description\" or dex --websocket-mode" # Updated error message
        exit 1
    else
        run_dex_orchestration "$@"
    fi
}

trap 'log_warn "Interrupted DEX process"; exit 1' INT TERM
[[ "${BASH_SOURCE[0]}" == "${0}" ]] && main "$@"
